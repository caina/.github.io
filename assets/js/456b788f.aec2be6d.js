(self.webpackChunkpersonal_blog=self.webpackChunkpersonal_blog||[]).push([[6977],{3905:function(e,t,r){"use strict";r.d(t,{Zo:function(){return c},kt:function(){return g}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(r),g=a,f=h["".concat(s,".").concat(g)]||h[g]||p[g]||o;return r?n.createElement(f,i(i({ref:t},c),{},{components:r})):n.createElement(f,i({ref:t},c))}));function g(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},2745:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u},default:function(){return p}});var n=r(2122),a=r(9756),o=(r(7294),r(3905)),i=["components"],l={id:"angular-simple-feature-toggle-that-works-outside-of-the-route",title:"Creating a featureToggle directive in Angular.",tags:["angular","front-end"]},s={permalink:"/blog/2019/10/09/angular-simple-feature-toggle-that-works-outside-of-the-route",source:"@site/blog/2019-10-09-angular-simple-feature-toggle-that-works-outside-of-the-route.md",title:"Creating a featureToggle directive in Angular.",description:"Photo by Anthony Intraversato on Unsplash",date:"2019-10-09T00:00:00.000Z",formattedDate:"October 9, 2019",tags:[{label:"angular",permalink:"/blog/tags/angular"},{label:"front-end",permalink:"/blog/tags/front-end"}],readingTime:2.58,truncated:!0,prevItem:{title:"Front-end for Single page applications(Angular, React, Vue) that scales with your team and how to makes sense of it.",permalink:"/blog/2019/11/20/frontend-angular-react-architecture-scales"},nextItem:{title:"Pushin to github in a pipeline without loging.",permalink:"/blog/2019/09/21/how-to-push-to-github-unauthenticated-in-pipeline"}},u=[],c={toc:u};function p(e){var t=e.components,l=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Photo by Anthony Intraversato on Unsplash",src:r(6217).Z})),(0,o.kt)("p",null,"This is kind of odd, but my PO wanted to have a feature toggle so our users would not see the new stuff but we want to test this thing against the real world. So let's build it because we libraries are way too dangerous these days \ud83d\udc7b."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Our feature toggle is going to rely on the browser query parameters to work, so in order to enable a feature, we'll have to navigate with the following URL: ",(0,o.kt)("inlineCode",{parentName:"p"},"localhost:4200?feature=search-bar"))),(0,o.kt)("p",null,"To use our feature toggle, we are going to create a directive, that we can easily attach to the component we want to toggle: ",(0,o.kt)("inlineCode",{parentName:"p"},"<app-search-bar *featureToggle=\"'search-bar'\" />"),"."),(0,o.kt)("p",null,"the ",(0,o.kt)("em",{parentName:"p"},"first")," thing that we need is to store every path parameter as features so we can toggle the hell out of our app. for this we are going to create a resolver:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-angular2"},"@Injectable({providedIn: 'root'})\nexport class FeatureResolver implements Resolve<void> {\n  constructor(private _featureService: FeatureService) {}\n\n  public resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): void {\n    const feature = route.queryParamMap.get('feature');\n    if (feature != null) {\n      this._featureService.addAvailableFeature(feature);\n    }\n  }\n}\n")),(0,o.kt)("p",null,"and this resolver is going to be used in our route as the route resolver:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const routes: Routes = [\n  {\n    path: '',\n    component: DashboardComponent,\n    resolve:[\n      FeatureResolver // <- thats the thing\n    ]\n  }\n];\n")),(0,o.kt)("p",null,"the idea here is that we can enable these features by route! Every time we enter the route we'll take the path parameters and store them in service. I mean, a singleton service! Be aware of it because if you provide it in the wrong place you'll not get the values from the route."),(0,o.kt)("p",null,"and this service is looking something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-angular2"},"@Injectable()\nexport class FeatureService {\n\n  private featuresSource = new BehaviorSubject<Array<String>>([]);\n  public $features = this.featuresSource.asObservable();\n\n  public addAvailableFeature(feature: string): void {\n    this.featuresSource.next([...this.featuresSource.value, feature])\n  }\n}\n")),(0,o.kt)("p",null,"In case you've never seen something like this pattern, this is an observable pattern, maybe we can talk about it later, but the advantage of this thing is that NO ONE TOUCH IN MY OBSERVABLE \ud83d\udc7a. You can read but not send data. "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Why the hell do we need this? as we are relying on the route to getter the path parameter, if the component you want to test is outside, like a header or a footer, it would not work, so we handle it using promises.")),(0,o.kt)("p",null,"and to finish, we just need the directive, and it's as simple as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-angular2"},"@Directive({selector: '[featureToggle]'})\nexport class FeatureToggleDirective implements OnInit {\n\n  @Input('featureToggle') feature: string;\n  \n  constructor(private featureService: FeatureService,\n    private templateRef: TemplateRef<any>,\n    private viewContainer: ViewContainerRef\n  ) {}\n\n  ngOnInit(): void {\n    this.featureService.$features.subscribe(features => {\n      if(features.includes(this.feature)) {\n        this.viewContainer.createEmbeddedView(this.templateRef);\n        } else {\n          this.viewContainer.clear();\n        }\n    })\n  }\n}\n")),(0,o.kt)("p",null,'The problem that I had is that the feature to be toggled is in the header, the header is outside of the route so the directive is resolved first, and the route would only collect the "features to be toggled" when angular finish to inject the route, to be worst, my route is being lazy loaded, so it takes even more time. This subscription actually solved a lot of problems.'))}p.isMDXComponent=!0},6217:function(e,t,r){"use strict";t.Z=r.p+"assets/images/airplane-004363389141148c3c95fc90dd14ec5f.jpg"}}]);