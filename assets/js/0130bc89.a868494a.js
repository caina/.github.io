(self.webpackChunkpersonal_blog=self.webpackChunkpersonal_blog||[]).push([[8446],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return f}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=u(e,["components","mdxType","originalType","parentName"]),h=s(n),f=o,d=h["".concat(c,".").concat(f)]||h[f]||p[f]||a;return n?r.createElement(d,i(i({ref:t},l),{},{components:n})):r.createElement(d,i({ref:t},l))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var u={};for(var c in t)hasOwnProperty.call(t,c)&&(u[c]=t[c]);u.originalType=e,u.mdxType="string"==typeof e?e:o,i[1]=u;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8254:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return u},metadata:function(){return c},toc:function(){return s},default:function(){return p}});var r=n(2122),o=n(9756),a=(n(7294),n(3905)),i=["components"],u={id:"angular-testing-without-before-each-for-a-better-code",title:"Angular TDD without BeforeEach, and why its a good idea.",tags:["angular","front-end","TDD"]},c={permalink:"/blog/2020/02/12/angular-testing-without-before-each",source:"@site/blog/2020-02-12-angular-testing-without-before-each.md",title:"Angular TDD without BeforeEach, and why its a good idea.",description:"Its been a while since I started to do some TDD with Angular and one of the things that start to bother me was the beforeEach mutations, you never know what is on the fixture, you never get if the component is being created on the beforeEach with the async, or the one without.",date:"2020-02-12T00:00:00.000Z",formattedDate:"February 12, 2020",tags:[{label:"angular",permalink:"/blog/tags/angular"},{label:"front-end",permalink:"/blog/tags/front-end"},{label:"TDD",permalink:"/blog/tags/tdd"}],readingTime:1.015,truncated:!0,prevItem:{title:"Simple Angular search highlighting text without dependencies",permalink:"/blog/2020/06/19/angular-highlight-component-scratch"},nextItem:{title:"The weight of a dependency in a modern SPA application",permalink:"/blog/2020/01/05/front-end-weight-of-node-modules"}},s=[],l={toc:s};function p(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Its been a while since I started to do some TDD with Angular and one of the things that start to bother me was the beforeEach mutations, you never know what is on the fixture, you never get if the component is being created on the beforeEach with the async, or the one without."),(0,a.kt)("p",null,'One way to solve this is to create a "setup" function, some simple like:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"describe('my test', function(){\n    function setUp() {\n        const routes = [\n            {path: 'test', component: MyComponent},\n        ] as Routes;\n\n        TestBed.configureTestingModule({\n          declarations: [MyComponent],\n          imports: [\n            TranslateModule.forRoot(), \n            RouterTestingModule.withRoutes(routes)\n          ],\n          providers: [TranslateService]\n        }).compileComponents();\n        \n        const router: Router = TestBed.get(Router);\n        const fixture = TestBed.createComponent(MyComponent);\n        \n        return {\n          fixture,\n          router\n        };\n    }\n    \n    it('should test', () => {\n        const {fixture} = setUp();\n        fixture.detectChanges();\n    }); \n\n});\n")),(0,a.kt)("p",null,"the Idea is to every test create the testbed and return it as an object, meanwhile the test that runs it would destruct the variables. No mutations, everyone is a const and you are now in charge of the code."),(0,a.kt)("p",null,"If you step into a problem that you have more then one scenario to cover, you can create multiple setups and they would never step in each other's toes, something that the beforeEach could not give you."))}p.isMDXComponent=!0}}]);