(self.webpackChunkpersonal_blog=self.webpackChunkpersonal_blog||[]).push([[5061],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(t),m=i,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||l;return t?a.createElement(h,r(r({ref:n},c),{},{components:t})):a.createElement(h,r({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var u=2;u<l;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5018:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return o},metadata:function(){return s},toc:function(){return u},default:function(){return p}});var a=t(2122),i=t(9756),l=(t(7294),t(3905)),r=["components"],o={id:"kotlin-coursera-class",title:"Kotlin Coursera class",sidebar_label:"Kotlin"},s={unversionedId:"kotlin-coursera-class",id:"kotlin-coursera-class",isDocsHomePage:!1,title:"Kotlin Coursera class",description:"Click here to get the exams code",source:"@site/docs/kotlin-coursera-class.md",sourceDirName:".",slug:"/kotlin-coursera-class",permalink:"/docs/kotlin-coursera-class",version:"current",sidebar_label:"Kotlin",frontMatter:{id:"kotlin-coursera-class",title:"Kotlin Coursera class",sidebar_label:"Kotlin"},sidebar:"someSidebar",previous:{title:"Bash Script snippets and tips",permalink:"/docs/bash-shell"},next:{title:"regex-cod3rs-class",permalink:"/docs/regex-cod3rs-class"}},u=[{value:"Cool features",id:"cool-features",children:[]},{value:"Data initialization, var, val and const",id:"data-initialization-var-val-and-const",children:[]},{value:"Lists",id:"lists",children:[]},{value:"Data class",id:"data-class",children:[]},{value:"Functions",id:"functions",children:[{value:"Library functions (run, let, takeIf...)",id:"library-functions-run-let-takeif",children:[]},{value:"Default values and positional paramters",id:"default-values-and-positional-paramters",children:[]}]},{value:"Conditionals: If &amp; when",id:"conditionals-if--when",children:[{value:"when as a switch",id:"when-as-a-switch",children:[]},{value:"Multiples conditions",id:"multiples-conditions",children:[]},{value:"Checking a type",id:"checking-a-type",children:[]}]},{value:"Loops",id:"loops",children:[{value:"Iterate over a map",id:"iterate-over-a-map",children:[]},{value:"Iterating over an index",id:"iterating-over-an-index",children:[]},{value:"Iterating over Ranges",id:"iterating-over-ranges",children:[]}]},{value:"Using <code>in</code> over Ranges",id:"using-in-over-ranges",children:[{value:"Using in into collections",id:"using-in-into-collections",children:[]}]},{value:"Comparables",id:"comparables",children:[]},{value:"Exceptions",id:"exceptions",children:[]},{value:"Extension Functions",id:"extension-functions",children:[{value:"Infix",id:"infix",children:[]}]},{value:"Nullable",id:"nullable",children:[{value:"Safe cast",id:"safe-cast",children:[]}]},{value:"Lambdas",id:"lambdas",children:[{value:"Sequences",id:"sequences",children:[]},{value:"lambda with receiver (DSL)",id:"lambda-with-receiver-dsl",children:[]},{value:"Return from lambda",id:"return-from-lambda",children:[]},{value:"Destructing declarations",id:"destructing-declarations",children:[]},{value:"Some different lambdas",id:"some-different-lambdas",children:[]}]},{value:"Function types",id:"function-types",children:[{value:"Calling a stored function",id:"calling-a-stored-function",children:[]},{value:"SAM interfaces (Single abstract method invocations)",id:"sam-interfaces-single-abstract-method-invocations",children:[]},{value:"Nullable function type",id:"nullable-function-type",children:[]}]},{value:"Member references",id:"member-references",children:[{value:"Function references",id:"function-references",children:[]},{value:"Passing function references as an argument",id:"passing-function-references-as-an-argument",children:[]}]},{value:"Properties",id:"properties",children:[{value:"Setting the field",id:"setting-the-field",children:[]},{value:"Setter visibility",id:"setter-visibility",children:[]},{value:"Property in interfaces",id:"property-in-interfaces",children:[]},{value:"Extension properties",id:"extension-properties",children:[]},{value:"Lazy property",id:"lazy-property",children:[]},{value:"Lateinit: Late initialization",id:"lateinit-late-initialization",children:[]}]},{value:"OOP in Kotlin",id:"oop-in-kotlin",children:[{value:"Enums class",id:"enums-class",children:[]},{value:"inner modifier",id:"inner-modifier",children:[]},{value:"Class delegation",id:"class-delegation",children:[]},{value:"Objects",id:"objects",children:[]},{value:"Companion object",id:"companion-object",children:[]}]},{value:"Generics",id:"generics",children:[]},{value:"Conventions",id:"conventions",children:[{value:"Arithmetic operations",id:"arithmetic-operations",children:[]},{value:"Comparisons",id:"comparisons",children:[]}]},{value:"Exams and tests",id:"exams-and-tests",children:[{value:"Week 2 exame: The Secret game",id:"week-2-exame-the-secret-game",children:[]},{value:"Kotlin Playground: Interchangeable predicates",id:"kotlin-playground-interchangeable-predicates",children:[]},{value:"Assignment: Nice Strings",id:"assignment-nice-strings",children:[]},{value:"Assignment: Taxi park",id:"assignment-taxi-park",children:[]},{value:"Unstable val",id:"unstable-val",children:[]},{value:"Rational Numbers",id:"rational-numbers",children:[]},{value:"Board",id:"board",children:[]},{value:"Fibonacci sequence",id:"fibonacci-sequence",children:[]}]}],c={toc:u};function p(e){var n=e.components,o=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},c,o,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("a",{parentName:"p",href:"https://caina.github.io/docs/kotlin-coursera-class#exams-and-tests"},"Click here to get the exams code"))),(0,l.kt)("p",null,"Kotlin is a general purpose language\nwhich supports both functional programming and object-oriented programming paradigms.\nIt's an open-source project developed mainly by JetBrains with the help of the community.\nLike Java, Kotlin is a statically typed language.\nHowever, in Kotlin you can omit the types, and it often looks as concise as some other dynamically-typed languages.\nKotlin is safe, it's even safer than Java in terms that,\nKotlin compiler can help to prevent even more possible types of errors.\nOne of the main characteristics of Kotlin is its good interoperability with Java.\nIt's hard now to call Java a modern language.\nHowever, it has so huge ecosystem, that it would be really difficult to recreate it from scratch if you use a new language"),(0,l.kt)("h2",{id:"cool-features"},"Cool features"),(0,l.kt)("hr",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There is no ",(0,l.kt)("inlineCode",{parentName:"li"},"new")," keyword."),(0,l.kt)("li",{parentName:"ul"},"There is no ",(0,l.kt)("inlineCode",{parentName:"li"},"static")," keyword."),(0,l.kt)("li",{parentName:"ul"},"The keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"object")," is a singleton in Kotlin: ",(0,l.kt)("inlineCode",{parentName:"li"},"object K {fun foo() {}}; K.foo()")," "),(0,l.kt)("li",{parentName:"ul"},"Type is inferd."),(0,l.kt)("li",{parentName:"ul"},"If is an expression, you can assign it to a variable."),(0,l.kt)("li",{parentName:"ul"},"There is no ternary operations."),(0,l.kt)("li",{parentName:"ul"},"Instead of throwing an exception, we can just call ",(0,l.kt)("inlineCode",{parentName:"li"},"fail()")),(0,l.kt)("li",{parentName:"ul"},"Smart casting",(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Having a class Pet that can be Dog or cat, we can do ",(0,l.kt)("inlineCode",{parentName:"p"},"pet.meow()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"pet.woof()"),", kotlin is going to do the cast for us "))),(0,l.kt)("li",{parentName:"ul"},"Formatting multiline strings ",(0,l.kt)("inlineCode",{parentName:"li"},'val q = """To code, or not to?"""')),(0,l.kt)("li",{parentName:"ul"},"There are no primitives"),(0,l.kt)("li",{parentName:"ul"},"Creating regex expressions")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val regex = """\\d{2}\\.d{2}\\.\\d{4}"""\nregex.matches("15.02.2016")\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Converters like: ",(0,l.kt)("inlineCode",{parentName:"li"},'"a".toIntOrNull()'),", ",(0,l.kt)("inlineCode",{parentName:"li"},'"1".toIn()'),",",(0,l.kt)("inlineCode",{parentName:"li"},'"1".toDouble()'),", "),(0,l.kt)("li",{parentName:"ul"},"equals infix")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun getAnswer() = 42\ngetAnswer() eq 42 // true\ngetAnswer() eq 43 // false\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Infix ",(0,l.kt)("inlineCode",{parentName:"li"},"to")," to create Pairs, like ",(0,l.kt)("inlineCode",{parentName:"li"},"val pair: Pair<Char, Double> = 'a' to 1.0")),(0,l.kt)("li",{parentName:"ul"},"Mutable Extensions properties")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"var StringBuilder.lastChar:Char\nget() = get(length -1)\nset(value:Char) {\n    this.setCharAt(length-1, value)\n}\n\nval sb = StringBuilder(\"Kotlin\")\nsb.lastChar = '!'\nprintln(sb) // Kotlin!\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"You need to define a class as ",(0,l.kt)("inlineCode",{parentName:"li"},"open")," sometimes because the default of a class is ",(0,l.kt)("inlineCode",{parentName:"li"},"final")),(0,l.kt)("li",{parentName:"ul"},"there is no package-private, instead its: ",(0,l.kt)("inlineCode",{parentName:"li"},"internal")),(0,l.kt)("li",{parentName:"ul"},"We can use ",(0,l.kt)("inlineCode",{parentName:"li"},"sealed")," modifier to restrict class hierarchy")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"sealed class Expr\nclass Num(val value: Int): Expr()\nclass Sum(val left:Expr, val Right: Expr): Expr()\n\nfun eval(e:Expr):Int = when(e) {\n    is Num -> e.value\n    is Sum -> eval(e.left) + eval(e.right)\n}\n\n// withouth the sealed modifier, it would need an else for it doesn't know where all the class inheriting from Expr are.\n")),(0,l.kt)("h2",{id:"data-initialization-var-val-and-const"},"Data initialization, var, val and const"),(0,l.kt)("hr",null),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'val: "value" its read-only'),(0,l.kt)("li",{parentName:"ul"},'var: "variable" its mutable'),(0,l.kt)("li",{parentName:"ul"},"const: For primitive types and Strings")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"about const: It's value is known at compile time, the compiler replaces the constant name everywhere in the code with this value, then it's called a compile-time constant. ")),(0,l.kt)("p",null,"We can initialize two variables using a Pair"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'fun updateWeather(degrees: Int) {\n    val(description, color) = when {\n        degrees < 10 -> Pair("cold", BLUE)\n        degrees < 25 -> "mild" to ORANGE // same as pair\n        else -> "hot" to RED\n    }\n}\n')),(0,l.kt)("h2",{id:"lists"},"Lists"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Kotlin has mutable an imutable lists, such as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val mutableList = mutableListOf("java")\nmutableList.add("Kotlin")\n\nval readOnlyList = listOf("Java")\nreadOnlyList.add("Kotlin") // <- that doesnt work\n')),(0,l.kt)("h2",{id:"data-class"},"Data class"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Data modifier has ",(0,l.kt)("inlineCode",{parentName:"p"},"equals"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"hashCode"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"to-string"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"copy")," methods. "),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"data class person(val name)"),"\nit creates:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Equals"),(0,l.kt)("li",{parentName:"ul"},"hashCode"),(0,l.kt)("li",{parentName:"ul"},"toString")),(0,l.kt)("p",null,"we can copy the instance and give the new attributes"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'data class Contact(val name:String, val address: String)\n\ncontact.copy(address="mew address")\n')),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"return void here is of type Unit"),(0,l.kt)("p",null,"We can define 3 types of fuctions "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Top level functions")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun topLevel() = 1\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Member function:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class A {\n fun member() = 2\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Local functions:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun other() {\n    fun local() = 3\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun max(a:Int, b:Int):Int {\n    return if (a>b) a else b\n}\n// that becomes\nfun max(a:Int, b:Int) = if (a>b) a else b\n")),(0,l.kt)("h3",{id:"library-functions-run-let-takeif"},"Library functions (run, let, takeIf...)"),(0,l.kt)("p",null,"functions that look like built-in language construct"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"run"),": Runs the block of code (lambda) and returns the last expession")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val foo = run{\n    println("calculating")\n    "foo"\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"let")," funtion: when you want to pass something as an argument only if it's non-null. ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun getEmail() : Email?\nval email = getEmail()\n\nif(email != null) sendEmailTo(email)\n// or better\nemail?.let {e -> sendEmailTo(e)}\n")),(0,l.kt)("p",null,"or to functions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun analizeUserSession(session:Session) = \n    (session.user as? FacebookUser)?.let {\n        println(it.accountId)\n    }\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"takeIf"),": returns the receiver if it satisfies the given predicate or returns null")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'issue.takeIf { it.status == FIXED }\nperson.patronymicName.takeIf(String::isNotEmpty)\n\nval number = 42 \nnumber.takeIf { it > 10 } // 42\n// if the predicate don\'t fullfill, it returns null\n\nissues.filter { it.status == OPEN }.takeIf(List<Issue>::isNotEmpty)?.let { println("some are open")}\n\n// filtering\npeople.mapNotNull { person -> person.takeIf { it.isPublicProfile }?.name }\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"takeUnless"),": is the opposite, takeUnless which returns the receiver if the predicate is not satisfied. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"repeat")," It simply repeats an action for a given number of times. ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'repeat(10) { println("Welcome!")}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"use"),": The use function contains all the aforementioned logic of closing the resources in the correct way. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"withLock")," lock the file"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"with"),": You can call all the members and extensions without explicit receiver specification ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val sb = StringBuilder()\nwith(sb) {\n    appendln(\"alphabet: \")\n    for(c in 'a'..'z'){\n        append(c)\n    }\n    toString()\n}\n// or\nwith(window) {\n    width = 300\n    height = 200\n    isVisible = true\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"run, but as an extension")," makes it possible to use it with a null-able receiver. ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val windowOrNull = windowById["main"]\nwindowOrNull?.run {\n    width = 300\n    height = 200\n    isVisible = true\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"apply"),": Is the same as with, but Apply is different because it ",(0,l.kt)("em",{parentName:"li"},"returns the receiver as a result"),". Its helpfull in a chain.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val mainWindow = windowById["main"]?.apply {\n    width = 300\n    height = 200\n    isVisible = true\n} ?: return\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"also"),": Also is similar to apply, it returns the receiver as well. However, there is the difference that it takes a regular lambda not lambda with a receiver as an argument. ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'windowById["main"]?.apply {\n    width = 300\n    height = 200\n    isVisible = true\n}?.also { window -> showWindow(window) }\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"he difference between all these functions",src:t(3063).Z})),(0,l.kt)("h3",{id:"default-values-and-positional-paramters"},"Default values and positional paramters"),(0,l.kt)("p",null,"we can specify default values for parameters, such as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun display(character: Char = \"*\", size: Int = 10) {\n    repeat(size) {\n        print(character)\n     }\n}\n\ndisplay('#', 5)\ndisplay('#')\ndisplay()\n// or direct the parameter\ndisplay(size=5)\n")),(0,l.kt)("p",null,"using the name position we can even change the order."),(0,l.kt)("p",null,"to call a kotlin function with default values, we need to suply an annotation to the function, like: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@JvmOverloads\nfun sun(a: Int=0, b: Int=0, c:Int=0)=a+b+c\n\n// java\nsum(1);\n")),(0,l.kt)("h2",{id:"conditionals-if--when"},"Conditionals: If & when"),(0,l.kt)("p",null,"if in kotlin is an expression, there is no ternary operations!"),(0,l.kt)("h3",{id:"when-as-a-switch"},"when as a switch"),(0,l.kt)("p",null,"You no longer needs to use break;"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'// java\nswitch(color) {\n   case BLUE:\n     System.out.printLn("cold");\n    break;\n   default:\n     System.out.printLn("hot");\n}\n\n//kotlin\nwhen(color) {\n    BLUE -> println("cold")\n    else -> println("hot")\n}\n')),(0,l.kt)("h3",{id:"multiples-conditions"},"Multiples conditions"),(0,l.kt)("p",null,"when can or not have parameters, so if it doesn't have, i''l check its cases for a boolean expression and evaluate them, so ",(0,l.kt)("inlineCode",{parentName:"p"},"when")," can be a group of ifs or a switch statement."),(0,l.kt)("p",null,"to check several conditions, you can specify like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'fun respondToInput(input:String) = when(input) {\n    "y", "yes" -> "I\'m glad you agree"\n    "n", "no" -> "Sorry to hear that"\n    else -> "I don\'t understand you"\n}\n')),(0,l.kt)("p",null,"or even comparing sets, the argument is checked for equality with the banch conditions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"when(setOf(c1, c2)){\n    setOf(RED,YELLOW) -> ORANGE\n}\n")),(0,l.kt)("h3",{id:"checking-a-type"},"Checking a type"),(0,l.kt)("p",null,"we can use ",(0,l.kt)("inlineCode",{parentName:"p"},"is")," to check a class type, like if pet is a super class of Cat and Dog we can check like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"when(pet) {\n    is Cat -> pet.meow()\n    is Dog -> pet.woof()\n}\n")),(0,l.kt)("p",null,"doing the same as the java ",(0,l.kt)("inlineCode",{parentName:"p"},"instanceof")),(0,l.kt)("h2",{id:"loops"},"Loops"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"The are basicly the same, but:"),(0,l.kt)("p",null,"For loop looks a bit different.\nFirst, a different keyword is used to\nexpress iteration over something in.\nSecond, where meets the element type. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'var list = listOf("a"."b","c")\nfor(s in list) {\n    print(s)\n}\n')),(0,l.kt)("h3",{id:"iterate-over-a-map"},"Iterate over a map"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val map = mapOf(1 to "one", 2 to "two", 3 to "three")\nfor((key, value) in map) {\n    println("$key = $value")\n}\n')),(0,l.kt)("h3",{id:"iterating-over-an-index"},"Iterating over an index"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val list = listOf("a", "b", "c")\nfor((index, element) in list.withIndex()) {\n    println("$index: $element")\n}\n')),(0,l.kt)("h3",{id:"iterating-over-ranges"},"Iterating over Ranges"),(0,l.kt)("p",null,"instead a forin loop we can use a range"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"for(i in 1..9){\n    print(i)\n}\n// -> 123456789\n\n// or until, excluding 9\nfor(i in 1 until 9){\n    print(i)\n}\n// -> 12345678\n")),(0,l.kt)("p",null,"or more complex cases like with a step"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"for(i in 0 downTo 1 step 2){\n    print(i)\n}\n// -> 97531\n")),(0,l.kt)("h2",{id:"using-in-over-ranges"},"Using ",(0,l.kt)("inlineCode",{parentName:"h2"},"in")," over Ranges"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"there are 2 ways to use it"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Iteration: ",(0,l.kt)("inlineCode",{parentName:"li"},"for(i in 'a'..'z')")),(0,l.kt)("li",{parentName:"ul"},"Check for belonging: ",(0,l.kt)("inlineCode",{parentName:"li"},"c in 'a'..'z'"))),(0,l.kt)("p",null,"EG, to check if a string is a letter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun isLetter(c:Char) = c in 'a'..'z' || c in 'A'..'Z'\nisLetter('q')// true\nisLetter(*) // false\n")),(0,l.kt)("p",null,"and it can be used in a when case as well."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"They can even be stored in a variable such as: ",(0,l.kt)("inlineCode",{parentName:"p"},"val intRange:IntRange = 1..9"))),(0,l.kt)("h3",{id:"using-in-into-collections"},"Using in into collections"),(0,l.kt)("p",null,"in can be used to check if an element is part of a list, in Java that would be like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"if(list.contains(element)) {}\n")),(0,l.kt)("p",null,"but in Kotlin we can do as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"if(element in list){...}\n")),(0,l.kt)("h2",{id:"comparables"},"Comparables"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"We can compare anithing that has a ",(0,l.kt)("inlineCode",{parentName:"p"},"compareTo"),", bein a code like the following"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class MyDate:Comparable<MyDate>\n\nif(myDate.compareTo(startDate) >= 0 && myDate.compareTo(endDate) <= 0) {...}\n")),(0,l.kt)("p",null,"can be rewrite in kotlin as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class MyDate:Comparable<MyDate>\nif(myDate >= startDate && myDate <= endDate) {...}\n\n// or even\n\nif(myDate in startDate..endDate){...}\n")),(0,l.kt)("h2",{id:"exceptions"},"Exceptions"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"They are very similar to Java with one important difference. Kotlin doesn't differentiate checked and unchecked exceptions. In Kotlin, you may or may not handle any exception, and your function does not need to specify which exception it can throw. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val percentage = \n    if (number in 0..100)\n        number\n    else\n        throw IllegalArgumentException("wron value: $value")\n')),(0,l.kt)("p",null,"being then try & catch an expression, being able to be assigned to varialbes, like following\n",(0,l.kt)("inlineCode",{parentName:"p"},"val number = try {Integer.parseInt(string)} catch(e:NumberFormatException) {null}")),(0,l.kt)("h2",{id:"extension-functions"},"Extension Functions"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Extension function extends the class.\nIt is defined outside of the class but can be\ncalled as a regular member to this class."),(0,l.kt)("p",null,"The general usecase for them is when you have a library and wants to extends its api, or something YOU DON'T HAVE POWER OVER."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'fun String.lastChar() = this.get(this.length -1) //this can be ommited\n\nfun String.lastChar() = get(length -1)\n\n// so we can use as\n"me".lastChar() // -> e\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"They are not freely accessible, you need to import them.")),(0,l.kt)("h3",{id:"infix"},"Infix"),(0,l.kt)("p",null,"there is a second way to extend a funtion with infix"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'infix fun <T> T.eq(other: T) {\n    if (this == other) println("OK")\n    else println("Error: $this != $other")\n}\n\nevaluateGuess("BCDF", "ACEB") eq result\n')),(0,l.kt)("h2",{id:"nullable"},"Nullable"),(0,l.kt)("hr",null),(0,l.kt)("p",null,'The introduction of null to earlier programming languages, is known to be called "billion dollar mistake". Because nulls are ubiquitous, NullPointerExceptions, attempts to dereference null pointers, are very common as an issue'),(0,l.kt)("p",null,"to define:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val s: String? // nullable\nval s: String // non nullable\n")),(0,l.kt)("p",null,"Elvis for null values: If we want to assing the lenght of a nullable variable to a non nullable, we can use an\nelvis to return a default one. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val lenght: Int = s?.length ?: 0 \n")),(0,l.kt)("p",null,"to throw an esception from accessing an value of a null object, just use: ",(0,l.kt)("inlineCode",{parentName:"p"},"person.company!!.address!!.country"),"\nbut prefer explicit checks"),(0,l.kt)("h3",{id:"safe-cast"},"Safe cast"),(0,l.kt)("p",null,"a safe way to cast an expression to a type. In Java, you use a common pattern to do something with the variable only if it is of specific type.\nFirst, you use instanceof to check whether the variable is of the required type, then you cast it to this type of restoring the result in a new variable"),(0,l.kt)("p",null,"Instead of using ",(0,l.kt)("inlineCode",{parentName:"p"},"instanceOf")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"typeCast")," we can simply use ",(0,l.kt)("inlineCode",{parentName:"p"},"is")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"as"),", but in the example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"as")," is not necessary"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"if(any is String) {\n    val s = any as String\n    s.toUpperCase()\n}\n")),(0,l.kt)("h2",{id:"lambdas"},"Lambdas"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Lambda is an anonymous function that can be used as an expression"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'button.addActionListner{ println("H1") }\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"we can store a lambda into a function ",(0,l.kt)("inlineCode",{parentName:"p"},"val sum = { x:Int, y:Int -> x+y }"),"\nBut we can't store a function in a variable")),(0,l.kt)("h3",{id:"sequences"},"Sequences"),(0,l.kt)("p",null,"filters and maps returns new values of a list, to avoid it we can use sequences, that are the same as stream"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Stream or sequences: If we use operations on collections, they eagerly return the result, while the operations on sequences postponed the actual computation, and therefore avoid creating intermediate collections. ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val list = listOf(1,2,-3)\nval maxOddSquare = list\n.asSequence() // same as .stream()\n.map{ it * it}\n.filter {it % 2 == 1}\n.max()\n")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"sequences output",src:t(9906).Z})),(0,l.kt)("h4",{id:"generating-a-sequence"},"Generating a sequence"),(0,l.kt)("p",null,"If you need to build a sequence from scratch, for instance, you define a way to receive each new element from the network, you can use the generateSequence function. Here, it generates a sequence of random numbers"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val seq = generateSequence {\n    Random.nextInt(5).takeIf { it > 0}\n}\nprintln(seq.toList())// [4,4,3,2,3,2]\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The generateSequence function can be useful when you need to read input and stop when a specific string is typed. ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val input = generateSequence {\n    readLine().takeIf { it != "exit" }\n}\nprintln(input.toList()) \n/*\n>> a\n>> b\n>> exit\n[a,b]\n*/\n')),(0,l.kt)("h4",{id:"generating-an-infinite-sequence"},"Generating an infinite sequence"),(0,l.kt)("p",null,"In this case, we generate an infinite sequence of integer numbers. Note that because this sequence is computed lazily, it might be infinite. Nothing happens until you explicitly ask for it. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val numbers = generateSequence(0) {it + 1}\nnumber.take(5).toList() // [1,2,3,4,5]\n")),(0,l.kt)("h4",{id:"yield"},"Yield"),(0,l.kt)("p",null,"Yield allows you to yield elements in a custom way.\nThe generic sequence functions that we\nsaw before, are white constraint"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val numbers = sequence {\n    var x = 0\n    while(true) {\n        yield(x++)\n    }\n}\nnumbers.take(5).toList() //[0,1,2,3,4,5]\n")),(0,l.kt)("h3",{id:"lambda-with-receiver-dsl"},"lambda with receiver (DSL)"),(0,l.kt)("p",null,"It might be considered as a union of two ideas of two other features: extension functions and lambdas."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"// lambda function\nval isEven: (Int) -> Boolean = { it%2 == 0 }\n// lambda with receiver\nval isOdd: Int.() -> Boolean = { this % 2 == 1 }\n\n// calling\nisEven(0)\n1.isOdd()\n")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"lambda-with-receiver",src:t(5553).Z})),(0,l.kt)("h3",{id:"return-from-lambda"},"Return from lambda"),(0,l.kt)("p",null,"Why in Kotlin return returns from the outer function? Consider the following example when you have a regular for loop and inside this for loop you use return. Return simply returns from the function. If you convert the for loop to foreach, then you can't expect that return continue to behave in the same way."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun containsZero(list: List<Int>): Boolean {\n    list.forEach {\n        if (it == 0) return true //this return the FUNCTION not the lambda!\n    }\n    return false\n}\n")),(0,l.kt)("p",null,"to return from the lambda we have to use the labels return syntax:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"list.flatMap {\n    if(it === 0) return@flatMap listOf<Int>()\n     listOf(it, it)\n}\n")),(0,l.kt)("p",null,"By default, you can use the name of the function that calls this lambda as a label. but we customize it"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"list.flatMap l@ {\n    if(it === 0) return@l listOf<Int>()\n     listOf(it, it)\n}\n")),(0,l.kt)("p",null,"if this is a problem, we can use a function inside of a function like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun duplicateNonZeriLocalFunctcion(list: List<Int>):List<Int> {\n    fun duplicateNonZeroElement(e: Int) :List<Int> {\n        if(e==0) return listOf()\n        return listOf(e,e)\n    }\n    return list.flatMap(::duplicateNonZeroElement)\n}\nprintln(duplicateNonZeriLocalFunctcion(listOf(3,0,5)))\n// [3,3,5,5]\n")),(0,l.kt)("p",null,"Or using an anonymous funcion"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun duplicateNonZeriLocalFunctcion(list: List<Int>):List<Int> {\n    return list.flatMap(fun (e) :List<Int> {\n        if(e==0) return listOf()\n        return listOf(e,e)\n    })\n}\nprintln(duplicateNonZeriLocalFunctcion(listOf(3,0,5)))\n// [3,3,5,5]\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The return from the lambda doesnt stop the loop, its like a ",(0,l.kt)("inlineCode",{parentName:"p"},"continue"))),(0,l.kt)("h3",{id:"destructing-declarations"},"Destructing declarations"),(0,l.kt)("p",null,"The same syntax was used to iterate over a map in a for loop, by assigning a key and a value to separate variables"),(0,l.kt)("p",null,"EG: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'map.mapValues{ entry-> "${entry.key} = ${entry.value}!" }\n')),(0,l.kt)("p",null,"can be declared as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'map.mapValues{ (key, value) -> "${key} = ${value}!" }\n// or\nmap.mapValues{ (_, value) -> "${value}!" }\n')),(0,l.kt)("h4",{id:"iterating-over-a-list-with-index"},"Iterating over a list with index"),(0,l.kt)("p",null,"Note that iterating over list with this index also works using destructuring declarations. With index, extension function returns a list of index to value elements. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'for((index, element) in list.withIndex()) {\n    println("$index $element")\n}\n')),(0,l.kt)("h4",{id:"destructing-declarations--data-classes"},"Destructing declarations & data classes"),(0,l.kt)("p",null,"You can use any data class as the right-hand side for the destructuring declarations, since the necessary component functions are automatically generated for it"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"data class Contact (\n    val name: String,\n    val email: String,\n    val phoneNumber: String\n)\n\nval (name, _, phoneNumber) = contact\n")),(0,l.kt)("h3",{id:"some-different-lambdas"},"Some different lambdas"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"partition"),": its the same as filter, but returns 2 lists: One that satisfies the predicate and another that don't")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val heroes = listOf(Hero("The Captain", 60, MALE),Hero("Lady Lauren", 29, FEMALE))\nval (youngest, oldest) = heroes.partition { it.age < 30 }\noldest.size\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"associateBy"),": the same as groupBy but removes the duplications, its a unique key, Eg:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val heroes = listOf(Hero("The Captain", 60, MALE),Hero("Frenchy", 42, MALE),Hero("Sir Stephen", 37, MALE))\nval mapByName: Map<String, Hero> = heroes.associateBy { it.name }\nmapByName["Frenchy"]?.age\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"associate"),": Creates a pair over a list: ",(0,l.kt)("inlineCode",{parentName:"li"},"listOf(1,2,3).associate{'a' + it to 10}")," that returns: a->10, b->20, c->30")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val heroes = listOf(Hero("The Captain", 60, MALE),Hero("Sir Stephen", 37, MALE))\nval mapByName = heroes.associate { it.name to it.age }\nmapByName.getOrElse("unknown") { 0 } //0\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"zip"),": returns a list of pair of 2 lists:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val a = listOf(1,2,3);\nval b = listOf('a', 'b', 'c')\na.zip(b)\n\n// 1->a, 2->b and 3->c\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"zipWithNext")," is the same as the zip, but it zips one list: ",(0,l.kt)("inlineCode",{parentName:"li"},"listOf(1,2,3,4)")," would be: 1->2 3->4"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"flatten")," combine lists of lists into one list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"flatMap")," can convert a string into a list of maps, and with ",(0,l.kt)("inlineCode",{parentName:"li"},"flatten")," we can merge then into 1 list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"filterValues"),": same as filter but for Pairs, ignoring the key"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"take")," takes only the fist x number of elements, like: ",(0,l.kt)("inlineCode",{parentName:"li"},"incomeByDriver.take(topTwentyDrivers).sum()")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"filterNotNull")," to remove null elements of a list"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"maxBy")," takes the maximum using the predicate, like:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val heroes = listOf(Hero("The Captain", 60, MALE), Hero("Frenchy", 42, MALE)) \nheroes.maxBy { it.age }?.name\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Another interesting detail about maxBy, it can return more than one list"),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val heroes = listOf(Hero("The Kid", 9, null),Hero("Lady Lauren", 29, FEMALE),Hero("First Mate", 29, MALE),Hero("Sir Stephen", 37, MALE))\nval mapByAge: Map<Int, List<Hero>> = heroes.groupBy { it.age }\nval (age, group) = mapByAge.maxBy { (_, group) ->  group.size }!!\nprintln(age) // 29\n'))),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"group-and-associate-by",src:t(7599).Z})),(0,l.kt)("h2",{id:"function-types"},"Function types"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"parameter types are written inside the parentheses and then an arrow, then the return type. In this case, is the type that takes two integer parameters and returns an integer as a result."),(0,l.kt)("p",null,"as a lambda: ",(0,l.kt)("inlineCode",{parentName:"p"},"val sum = { x:Int, y:Int -> x+y }"),"\nwe can give it a type by:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val sum: (Int, Int) -> Int = {x,y -> x+y}\n")),(0,l.kt)("h3",{id:"calling-a-stored-function"},"Calling a stored function"),(0,l.kt)("p",null,"You can call a variable a function type as a regular function, providing all the unnecessary arguments. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val isEven: (Int) -> Boolean = {x:Int -> i%2 == 0}\nval result:Boolean = isEven(42) // true \n\nor as an lambda: \nlistOf(1,2,3).any(isEven) // true\nlist.filter(isEven) // [2,4]\n")),(0,l.kt)("p",null,"We can run labdas by: ",(0,l.kt)("inlineCode",{parentName:"p"},'{println("hey")}()')," or better: ",(0,l.kt)("inlineCode",{parentName:"p"},'run {println("hey")}')),(0,l.kt)("h3",{id:"sam-interfaces-single-abstract-method-invocations"},"SAM interfaces (Single abstract method invocations)"),(0,l.kt)("p",null,"In Java, you can pass a Lambda instead of a SAM interface, an interface with only one single abstract method. In Kotlin, you can use the function types directly, but when you mix Kotlin and Java, you'd want to do the same as in Java. Whenever you call a method that takes SAM interface as a parameter, you can pass a Lambda as an argument to this method instead."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"void postponeComputation(int delay, Runnable computation)\n\n// SAM interface\npublic interface Runnable {\n    public abstract void run();\n}\n")),(0,l.kt)("p",null,"Whenever you call a method that takes SAM interface as a parameter, you can pass a Lambda as an argument to this method instead.\n",(0,l.kt)("inlineCode",{parentName:"p"},"postponeComputation(1000) {println(42)}")," "),(0,l.kt)("p",null,"or if you want to use the constructor:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val runnable = Runnable {printl(42)}\npostponeComputation(1000, runnable) \n")),(0,l.kt)("h3",{id:"nullable-function-type"},"Nullable function type"),(0,l.kt)("p",null,"The first one means that, return type is nullable. That's a possible mistake when you simply add a question mark after the function type. It means that you make the return type of this function type nullable, not the whole type itself. If you want to make the whole type nullable, you need to use the parentheses. In the example, you saw null in curly braces. It's a Lambda without arguments that always returns null. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"() ->Int? // return type is null\n(() -> Int)? // the variable is null\n")),(0,l.kt)("p",null,"calling a null function"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val f: (()-> Int)? = null\n\nif(f != null) {\n    f()\n}   \n// or safe call\nf?.invoke()\n")),(0,l.kt)("h2",{id:"member-references"},"Member references"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Like Java, Kotlin has member references, which can replace simple Lambdas that only call a member function or return a member property."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Person(val name: String, val age: Int)\n\npeople.maxBy {it.age}\n// or\npeople.maxBy(Person::age)\n// Person is the class\n// age is the member\n")),(0,l.kt)("p",null,"if the reproached function takes several arguments, you have to repeat all the parameter names as Lambda parameters, and then explicitly pass them through, that makes this syntax robust. Member references allow you to hide all the parameters, because the compiler infers the types for you."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val action = {person: Person, message: String -> sendEmail(person, message)}\n// same as\nval action = ::sendMail \n")),(0,l.kt)("h3",{id:"function-references"},"Function references"),(0,l.kt)("p",null,"If you try to assign a function to a variable, you'll get a compiler error. To fix this issue, use the function reference syntax. Function references allow you to store a reference to any defined function in a variable to be able to store it and qualitative it. Keep in mind that this syntax is just another way to call a function inside the Lambda, underlying implementation are the same. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun isEven(i:Int):Boolean = i%2==0\nval predicate = ::isEven\n// the same as\nval predicate = { i:Int -> isEven(i)}\n")),(0,l.kt)("h3",{id:"passing-function-references-as-an-argument"},"Passing function references as an argument"),(0,l.kt)("p",null,"whenever your Lambda tends to grow too large and to become too complicated, it makes sense to extract Lambda code into a separate function, then you use a reference to this function instead of a huge Lambda"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun isEven(i:Int): Boolean = i%2==0\nval list = listOf(1,2,3,4)\nlist.any(::isEven) // true\nlist.filter(::isEven) [2,4]\n")),(0,l.kt)("p",null,"Static and non static access:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'class Person(val name: String, val age: Int) {\n    fun isOlder(ageLimit:Int) = age > ageLimit\n}\n\nval agePredicate = Person::isOlder // non-bound or static\nval alice = Person("alice", 29)\nagePredicate(alice, 29) // true\n\n// bounded or non-static\nval alice = Person("Alice", 29)\nval agePredicate = alice::isOlder\nagePredicate(21) // true\n\n// and bound to this references\nclass Person(val name: String, val age: Int) {\n    fun isOlder(ageLimit:Int) = age > ageLimit\n\n    fun getAgePredicate() = this::isOlder //we can ommit the this (::isOlder)\n}\n')),(0,l.kt)("h2",{id:"properties"},"Properties"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Unlike Java where a property is not a language construct. Kotlin supports it as a separate language feature. In a most common scenario for a trivial case, property syntaxes are really concise. But you can customize it if needed"),(0,l.kt)("p",null,"This is an customization of these field"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Retangle(val height: Int, val width: Int) {\n\n    val isSquare: Boolean\n        get() {\n            return height == width\n        }\n}\n\nval rectangle = Rectangle(2,3)\nprintln(rectangle.isSquare) // false\n")),(0,l.kt)("h3",{id:"setting-the-field"},"Setting the field"),(0,l.kt)("p",null,"In Kotlin, you don't work with fields directly, you work with properties.\nHowever, if you need, you can access a field inside its property accessors.\nIt's not visible for other methods of the class. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'var state = false\n    set(value) {\n        print("setting state to $field")\n        field = value\n    }\n')),(0,l.kt)("h3",{id:"setter-visibility"},"Setter visibility"),(0,l.kt)("p",null,"You can make a setter private.\nThen the getter is accessible everywhere.\nAnd therefore the property is accessible everywhere.\nBut it's allowed to modify it only inside the same class.\nNote that we change only the visibility of the setter, but\nuse the default implementation. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"var sample:Boolean = false\nprivate set\n")),(0,l.kt)("h3",{id:"property-in-interfaces"},"Property in interfaces"),(0,l.kt)("p",null,"You can define a property in an interface.\nWhy not? Under the hood,\nit's just a getter.\nThen you can redefine\nthis getter in subclasses in the way you want. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"interface User {\n    val nickname: String\n}\n\nclass FacebookUser(val accountId: Int): User {\n    override val nickname = getFacebookName(accountId)\n}\n")),(0,l.kt)("h3",{id:"extension-properties"},"Extension properties"),(0,l.kt)("p",null,"In Kotlin, you can define extension properties.\nThe syntax is very similar to\nthe one of defining extension functions. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val String.lasIndex:Int \n    get() = this.length\n\nval String.indices: IntRange\n    get() = 0..lasIndex\n\n// "abc".lasIndex\n')),(0,l.kt)("h3",{id:"lazy-property"},"Lazy property"),(0,l.kt)("p",null,"Lazy Property is a property which\nvalues are computed only on the first success. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'val lazyValue: String by lazy { \n    println("computed")\n    "Hello"\n}\n')),(0,l.kt)("h3",{id:"lateinit-late-initialization"},"Lateinit: Late initialization"),(0,l.kt)("p",null,"Sometimes, we want to\ninitialize the property not in the constructor,\nbut in a specially designated for that purpose method.\nHere, we initialized\nthe myData property in onCreate method,\nbut not in the constructor"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'class KotlinActivity: Activity {\n    lateinit var MyData: MyData\n    \n    fun create() {\n        myData = intent.getParcelableExtra("MY_DATA")\n    }\n}\n')),(0,l.kt)("h2",{id:"oop-in-kotlin"},"OOP in Kotlin"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"\ud83e\udd28 Overall, Kotlin doesn't introduce anything conceptually new here, the experience is very similar."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"key"),(0,l.kt)("th",{parentName:"tr",align:null},"value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"final"),(0,l.kt)("td",{parentName:"tr",align:null},"used by default, cannot be overridden")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"open"),(0,l.kt)("td",{parentName:"tr",align:null},"can be overridden")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"abstract"),(0,l.kt)("td",{parentName:"tr",align:null},"must be overridden, can't have an implementation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"override"),(0,l.kt)("td",{parentName:"tr",align:null},"mandatory, overrides a member in a superclass or interface")))),(0,l.kt)("p",null,"When you put val or var before the parameter, that automatically creates a property. Without val or var, it's on the constructor parameter.  "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Person(name: String) {\n    val name: String\n\n    init {\n        this.name = name\n    }\n}\n// or\nclass Person(val name:String)\n")),(0,l.kt)("p",null,"\ud83d\ude00 You can hame multiple constructors, but each secondary constructor must call another secondary or primary constructor"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Rectangle(val height: Int, val width: Int) {\n\n    constructor(side: Int) : this(side, side) {   \n    }\n}\n")),(0,l.kt)("h3",{id:"enums-class"},"Enums class"),(0,l.kt)("p",null,"The difference with Java is that\nnow enum is not a separate instance,\nbut a modifier before the class keyword. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'import Color.*\n\nenum class Color {\n    BLUE, ORANGE, RED\n}\n\nfun getDescription(color: Color) {\n    when(color) {\n        RED->"cold"\n        ORANGE -> "mild"\n        RED -> "hot"\n    }\n}\n')),(0,l.kt)("h3",{id:"inner-modifier"},"inner modifier"),(0,l.kt)("p",null,"To access this reference of the outer class,\nyou use labeled this.\nAs the label name, you\nspecify the name of the outer class. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class A {\n    class B\n    inner class C {\n        ...this@A...\n    }\n}\n")),(0,l.kt)("h3",{id:"class-delegation"},"Class delegation"),(0,l.kt)("p",null,"In essence, class delegation allows you to\ndelegate the task of\ngenerating trivial matters to the compiler.\nNote that the controller class\nimplements both interfaces,\nso we can call interface members on it"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Controller(\n    repository: Repository,\n    logger: Logger \n): Repository by repository, Logger by logger\n")),(0,l.kt)("h3",{id:"objects"},"Objects"),(0,l.kt)("p",null,"The keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"object")," is a singleton in Kotlin: ",(0,l.kt)("inlineCode",{parentName:"p"},"object K {fun foo() {}}; K.foo()")," "),(0,l.kt)("p",null,"Objects Expressions replace java's anonymous classes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"window.addMouseListner (\n    object: MouseAdapter() {\n        override fun mouseClicked(e: MouseEvent) {}\n        override fun mouseEntered(e: MouseEvent) {}\n    }\n)\n")),(0,l.kt)("h3",{id:"companion-object"},"Companion object"),(0,l.kt)("p",null,"It's a nested object inside a class but a special one.\nThe one which members can be accessed by the class name.\nIn Kotlin, there are no static methods like in Java,\nand companion objects might be a replacement for that. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class A {\n    companion object {\n        fun foo() = 1\n    }\n}\nfun main(args: Array<String>){\n    A.foo()\n}\n")),(0,l.kt)("h4",{id:"companion-object-can-implment-an-interface"},"Companion object can implment an interface"),(0,l.kt)("p",null,"It would be nice if a static method\ncould override a member of an interface.\nBut for static, that's not possible in java.\nNow, it's possible for companion object. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"interface Factory<T> {\n    fun create():T\n}\nclass A{\n    private constructor()\n    companion object : Factory<A> {\n        override fun create(): A {\n            return A()\n        } \n    }\n}\n")),(0,l.kt)("h4",{id:"companion-object-can-be-a-receiver-of-an-extension-function"},"companion object can be a receiver of an extension function"),(0,l.kt)("p",null,"Another thing which you can do with companion object,\nis you can define extension straight.\nTo distinguish an extension to\na class from an extension to a companion object,\nyou use the companion suffix. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Person(val firstName: String, val lastName: String) {\n    companion object{...}\n}\n\nfun Person.Companion.fromJson(json: String): Person {\n...\n}\n\nval p = Person.fromJSON(json)\n")),(0,l.kt)("h2",{id:"generics"},"Generics"),(0,l.kt)("p",null,"You define a type parameter for a function and try to\nuse this type parameter in the function declaration,\ninto the function body.\nYou can call a generic function on different types. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun <T> List<T>.filter(predicate: (T)-> Boolean): List<T>\n")),(0,l.kt)("h4",{id:"non-nullable-upper-bound"},"Non-nullable upper bound"),(0,l.kt)("p",null,"If you want to restrict the generic argument so that it was not nullable, you can specify a non-null upper bound. You add an upper bound right after the type parameter declaration using the same column which replaces the extents cube root in Kotlin"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun <T: Any> foo(list: List<T>) {\n    for(element in list) {}\n}\n\nfoo(listOf(1, null)) // exception\n")),(0,l.kt)("h4",{id:"multiple-constrains-for-a-type-parameter"},"Multiple constrains for a type parameter"),(0,l.kt)("p",null,"Here, you can pass any type that extends to different interfaces, terrace sequence and aboundable. Stringbuilder implements both terrace sequence and dependable, so it's a valid argument for these function. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"fun <T> ensureTrailingPeriod(seq: T)\n     where T: CharSequence, T: Appendable {\n        if(!seq.endsWith('.')) {\n            seq.append('.')\n        }\n}\n\nval helloWorld = StringBuilder(\"Hello, World\")\nensureTrailingPeriod(helloWorld)\nprintln(helloWorld) // \"Hello, World.\n")),(0,l.kt)("h2",{id:"conventions"},"Conventions"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"accessing map elements using square brackets, actually work via conventions, and the same syntax might be supported for your custom process. "),(0,l.kt)("h3",{id:"arithmetic-operations"},"Arithmetic operations"),(0,l.kt)("p",null,"In Kotlin, you can use this syntax of arithmetic operations not only primitives or strings, but for custom types as well. You define a function, a member or an extension with a specific name and mark it as operator. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"// a + b -> a.plus(b)\n\noperator fun Poin.plus(other: Point): Point {\n    return Point(x + other.x, y + other.y)\n}\n")),(0,l.kt)("p",null,"It's not that you can use any name. You can see the correspondence between the syntax and the operator name that allows you to use this syntax. "),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"expression"),(0,l.kt)("th",{parentName:"tr",align:null},"function name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a + b"),(0,l.kt)("td",{parentName:"tr",align:null},"plus")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a - b"),(0,l.kt)("td",{parentName:"tr",align:null},"minus")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a * b"),(0,l.kt)("td",{parentName:"tr",align:null},"times")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a / b"),(0,l.kt)("td",{parentName:"tr",align:null},"div")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a % b"),(0,l.kt)("td",{parentName:"tr",align:null},"mod")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"And the unary operators:")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"expression"),(0,l.kt)("th",{parentName:"tr",align:null},"function name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"+a"),(0,l.kt)("td",{parentName:"tr",align:null},"unaryPlus")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-a"),(0,l.kt)("td",{parentName:"tr",align:null},"unaryMinus")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"!a"),(0,l.kt)("td",{parentName:"tr",align:null},"not")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"++a, a++"),(0,l.kt)("td",{parentName:"tr",align:null},"inc")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"--a, a--"),(0,l.kt)("td",{parentName:"tr",align:null},"dec")))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Unary operator is a function without arguments which we can call as an operator on this specified receiver. ")),(0,l.kt)("h4",{id:"prefer-val-to-var"},"Prefer val to var"),(0,l.kt)("p",null,"assigning the value like the following will create a new list, like: ",(0,l.kt)("inlineCode",{parentName:"p"},"list = list + 4")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"var list = listOf(1,2,3)\nlist += 4\n")),(0,l.kt)("h3",{id:"comparisons"},"Comparisons"),(0,l.kt)("p",null,"Under the hood, the comparison operators are all compiled using the comparative method comparisons. "),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"symbol"),(0,l.kt)("th",{parentName:"tr",align:null},"translate to"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a > b"),(0,l.kt)("td",{parentName:"tr",align:null},"a.compareTo(b) > 0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a < b"),(0,l.kt)("td",{parentName:"tr",align:null},"a.compareTo(b) < 0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a >= b"),(0,l.kt)("td",{parentName:"tr",align:null},"a.compareTo(b) >= 0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"a <= b"),(0,l.kt)("td",{parentName:"tr",align:null},"a.compareTo(b) <= 0")))),(0,l.kt)("h4",{id:"accessing-elements-by-index-"},"Accessing elements by index: []"),(0,l.kt)("p",null,"Under the hood, the get and set methods are called"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"map[key]\nmutableMap[key] = newValue\n\n// is translate to\nx[a,b] -> x.get(a, b)\nx[a,b] = c -> x.set(a,b,c)\n")),(0,l.kt)("p",null,"You can define get and set operator functions as members or extensions for your own custom classes. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"class Board {}\nboard[1,2] = 'x'\nboard[1,2] // x\n\noperator fun Board.get(x: Int, y: Int): Char {...}\noperator fun Board.set(x: Int, y: Int) {...}\n")),(0,l.kt)("h4",{id:"the-iterator-convention"},"The iterator convention"),(0,l.kt)("p",null,"For loop iteration also goes through a convention. In Kotlin, you can iterate over a string. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'operator fun CharSequence.iterator() : CharIterator\nfor(c in "abc"){}\n')),(0,l.kt)("h2",{id:"exams-and-tests"},"Exams and tests"),(0,l.kt)("p",null,"Every week we have an exame, these are the projects solving them:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://gitlab.com/caina/learning/-/tree/master/kotlin/Kotlin%20for%20Java%20Developers.%20Week%202"},"Week 2 Exam: Mastermind")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://gitlab.com/caina/learning/-/tree/master/kotlin/Kotlin%20for%20Java%20Developers.%20Week%203"},"Week 3 Exam: Nice String and Taxi Park")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://gitlab.com/caina/learning/-/tree/master/kotlin/Kotlin%20for%20Java%20Developers.%20Week%204"},"Week 4 Exam: Rationals and Board")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://gitlab.com/caina/learning/-/tree/master/kotlin/Kotlin%20for%20Java%20Developers.%20Week%205"},"Week 5 Exam: Games"))),(0,l.kt)("h3",{id:"week-2-exame-the-secret-game"},"Week 2 exame: The Secret game"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"data class Evaluation(val rightPosition: Int, val wrongPosition: Int)\n\nfun evaluateGuess(secret: String, guess: String): Evaluation {\n    val totalSecret: MutableList<Pair<Int, Char>> = secret.subtract(guess)\n    val totalGuess: MutableList<Pair<Int, Char>> = guess.subtract(secret)\n\n    return Evaluation(\n            rightPosition = calculateRightGuess(secret, totalSecret),\n            wrongPosition = calculateWrongPositions(totalSecret, totalGuess)\n    )\n}\n\nprivate fun calculateRightGuess(secret: String, totalSecret: MutableList<Pair<Int, Char>>) = secret.length - totalSecret.size\nprivate fun calculateWrongPositions(totalSecret: MutableList<Pair<Int, Char>>, totalGuess: MutableList<Pair<Int, Char>>): Int {\n    var wrong = 0\n    totalSecret.forEach {\n        val found = totalGuess.findChar(it.second)\n        if (found != null) {\n            wrong++\n            totalGuess.remove(found)\n        }\n    }\n    return wrong\n}\n\nprivate fun String.asIndexMap() = this.toCharArray().mapIndexed { index, c -> index to c }.toMutableList()\nprivate fun String.subtract(from: String) = this.asIndexMap().minus(from.asIndexMap()).toMutableList()\nprivate fun MutableList<Pair<Int, Char>>.findChar(needle: Char) = this.find { it.second == needle }\n")),(0,l.kt)("h3",{id:"kotlin-playground-interchangeable-predicates"},"Kotlin Playground: Interchangeable predicates"),(0,l.kt)("p",null,"Functions 'all', 'none' and 'any' are interchangeable, you can use one or the other to implement the same functionality.\nImplement the functions 'allNonZero' and 'containsZero' using all three predicates in turn.\n'allNonZero' checks that all the elements in the list are non-zero; 'containsZero' checks that the list contains zero element.\nAdd the negation before the whole call (right before 'any', 'all' or 'none') when necessary, not only inside the predicate."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'fun List<Int>.allNonZero() = all { it != 0 }\nfun List<Int>.allNonZero1() = none { it == 0 }\nfun List<Int>.allNonZero2() = !any { it == 0 }\n\nfun List<Int>.containsZero() = any { it == 0 }\nfun List<Int>.containsZero1() = !all { it != 0 }\nfun List<Int>.containsZero2() = !none { it == 0 }\n\nfun main(args: Array<String>) {\n    val list1 = listOf(1, 2, 3)\n    list1.allNonZero() eq true\n    list1.allNonZero1() eq true\n    list1.allNonZero2() eq true\n\n    list1.containsZero() eq false\n    list1.containsZero1() eq false\n    list1.containsZero2() eq false\n\n    val list2 = listOf(0, 1, 2)\n    list2.allNonZero() eq false\n    list2.allNonZero1() eq false\n    list2.allNonZero2() eq false\n\n    list2.containsZero() eq true\n    list2.containsZero1() eq true\n    list2.containsZero2() eq true\n}\n\ninfix fun <T> T.eq(other: T) {\n    if (this == other) println("OK")\n    else println("Error: $this != $other")\n}\n')),(0,l.kt)("h3",{id:"assignment-nice-strings"},"Assignment: Nice Strings"),(0,l.kt)("p",null,"Nice String"),(0,l.kt)("p",null,"A string is nice if at least two of the following conditions are satisfied:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It doesn't contain substrings bu, ba or be;"),(0,l.kt)("li",{parentName:"ul"},"It contains at least three vowels (vowels are a, e, i, o and u);"),(0,l.kt)("li",{parentName:"ul"},'It contains a double letter (at least two similar letters following one another), like b in "abba".')),(0,l.kt)("p",null,"Your task is to check whether a given string is nice. Strings for this task will consist of lowercase letters only. Note that for the purpose of this task, you don't need to consider 'y' as a vowel."),(0,l.kt)("p",null,'Note that any two conditions might be satisfied to make a string nice. For instance, "aei" satisfies only the conditions #1 and #2, and ``',(0,l.kt)("inlineCode",{parentName:"p"},'"nn"')," satisfies the conditions #1 and #3, which means both strings are nice."),(0,l.kt)("p",null,"Example 1"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'"bac" isn\'t nice. No conditions are satisfied: it contains a ba substring, contains only one vowel and no doubles.')),(0,l.kt)("p",null,"Example 2"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\"aza\" isn't nice. Only the first condition is satisfied, but the string doesn't contain enough vowels or doubles.")),(0,l.kt)("p",null,"Example 3"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\"abaca\" isn't nice. The second condition is satisfied: it contains three vowels a, but the other two aren't satisfied: it contains ba and no doubles.")),(0,l.kt)("p",null,"Example 4"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'"baaa" is nice. The conditions #2 and #3 are satisfied: it contains three vowels a and a double a.')),(0,l.kt)("p",null,"Example 5"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},'"aaab" is nice, because all three conditions are satisfied.')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"val VOWELS = listOf('a', 'e', 'i', 'o', 'u')\nval forbiddenWords = listOf(\"ba\", \"be\", \"bu\")\n\nfun String.isNice(): Boolean {\n    var total = 0\n\n    val hasNotForbiddenWords = { input: String -> if (forbiddenWords.none{ input.contains(it)}) 1 else 0 }\n    val hasMoreThenThreeVOWELS = { input: String -> if (input.count(VOWELS::contains) >= 3) 1 else 0 }\n    val hasDoubleLetters = { input: String -> if (input.zipWithNext().count { it.first == it.second } > 0) 1 else 0 }\n\n    total += hasNotForbiddenWords(this)\n    total += hasMoreThenThreeVOWELS(this)\n    total += hasDoubleLetters(this)\n\n    return total > 1\n}\n")),(0,l.kt)("h3",{id:"assignment-taxi-park"},"Assignment: Taxi park"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"/*\n * Task #1. Find all the drivers who performed no trips.\n */\nfun TaxiPark.findFakeDrivers(): Set<Driver> = allDrivers.minus(trips.map { it.driver }.toSet())\n\n/*\n * Task #2. Find all the clients who completed at least the given number of trips.\n */\nfun TaxiPark.findFaithfulPassengers(minTrips: Int): Set<Passenger> {\n    val byPassenger = trips.map { it.passengers }\n\n    return allPassengers.filter {\n        byPassenger.count { trip -> trip.contains(it) } >= minTrips\n    }.toSet()\n}\n\n/*\n * Task #3. Find all the passengers, who were taken by a given driver more than once.\n */\nfun TaxiPark.findFrequentPassengers(driver: Driver): Set<Passenger> = trips\n        .filter { it.driver == driver }\n        .flatMap (Trip::passengers)\n        .groupBy { passenger -> passenger }\n        .filterValues {group -> group.size > 1 }\n        .keys\n\n/*\n * Task #4. Find the passengers who had a discount for majority of their trips.\n */\nprivate fun Passenger.hadMoreTripsWithDiscount(trips: List<Trip>): Boolean {\n    val totalRides = trips.filter { it.passengers.contains(this) }.map { it.discount }\n    val ridesWithoutDiscount = totalRides.filter(Objects::isNull).size\n    val ridesWithDiscount = totalRides.filter(Objects::nonNull).size\n\n    return ridesWithDiscount > ridesWithoutDiscount\n}\n\nfun TaxiPark.findSmartPassengers(): Set<Passenger> = allPassengers.filter { it.hadMoreTripsWithDiscount(trips) }.toSet()\n\n/*\n * Task #5. Find the most frequent trip duration among minute periods 0..9, 10..19, 20..29, and so on.\n * Return any period if many are the most frequent, return `null` if there're no trips.\n */\nfun TaxiPark.findTheMostFrequentTripDurationPeriod(): IntRange? {\n    return trips\n        .groupBy{\n            val start = it.duration /10 * 10\n            val end = start + 9\n            start..end\n        }\n        .maxBy{(_,group) -> group.size}\n        ?.key\n}\n\n/*\n * Task #6.\n * Check whether 20% of the drivers contribute 80% of the income.\n */\nfun TaxiPark.checkParetoPrinciple(): Boolean {\n    if(this.trips.isEmpty()) {\n        return false\n    }\n    val incomeByDriver = trips\n            .groupBy { it.driver }\n            .map { (_, tripsByDriver) -> tripsByDriver.sumDouble(Trip::cost)}\n            .sortedByDescending { it }\n\n    val topTwentyDrivers = (allDrivers.size * 0.2).roundToInt()\n    var income = incomeByDriver.take(topTwentyDrivers).sum()\n\n\n    val total = trips.sumByDouble(Trip::cost)\n    val percentage = income * 100 / total\n    return percentage >= 80\n}\n")),(0,l.kt)("h3",{id:"unstable-val"},"Unstable val"),(0,l.kt)("p",null,"Implement the property 'foo' so that it produced a different value on each access. Note that you can modify the code outside the 'foo' getter (e.g. add additional imports or properties)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"var foo: Int = 0\n    get():Int  {\n       field += 1\n       return field\n    }\n\nfun main(args: Array<String>) {\n    // The values should be different:\n    println(foo)\n    println(foo)\n    println(foo)\n}\n")),(0,l.kt)("h3",{id:"rational-numbers"},"Rational Numbers"),(0,l.kt)("p",null,"Your task is to implement a class Rational representing rational numbers. A rational number is a number expressed as a ratio n/d , where n (numerator) and d (denominator) are integer numbers, except that d cannot be zero."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'package rationals\n\nimport java.math.BigInteger.ONE\nimport java.math.BigInteger.ZERO\nimport java.math.BigInteger\n\nclass Rational(val numerator: BigInteger, val denominator: BigInteger) {\n\n    companion object {\n        private fun minCommonDivisor(denominatorA: BigInteger, denominatorB: BigInteger): BigInteger {\n            val maxCommonDivisor = denominatorA.gcd(denominatorB)\n            return denominatorA * (denominatorB / maxCommonDivisor)\n        }\n\n        fun toSameBase(first: Rational, second: Rational): Pair<Rational, Rational> {\n            val mmc = minCommonDivisor(first.denominator, second.denominator)\n\n            val firstEquivalentRational = Rational(first.toEquivalentNumerator(mmc), mmc)\n            val secondEquivalentRational = Rational(second.toEquivalentNumerator(mmc), mmc)\n\n            return firstEquivalentRational to secondEquivalentRational\n        }\n    }\n\n    fun toEquivalentNumerator(mmc: BigInteger) = this.numerator * (mmc / this.denominator)\n\n    /*\n    The denominator must be always positive in the normalized form.\n    If the negative rational is normalized, then only the numerator can be negative,\n    e.g. the normalized form of 1/-2 should be -1/2.wq\n    */\n    fun normalize(): Rational {\n        if (numerator == ZERO) return this\n\n        val maxDivider = numerator.gcd(denominator)\n        val normalized = Rational(\n                numerator = numerator / maxDivider,\n                denominator = (denominator / maxDivider).abs()\n        )\n\n        return when {\n            denominator < ZERO -> -normalized\n            else -> normalized\n        }\n    }\n\n    override fun toString(): String {\n        return when (denominator) {\n            ONE -> numerator.toString()\n            else -> "$numerator/$denominator"\n        }\n    }\n\n    override fun equals(other: Any?) = when (other) {\n        is Rational -> this.numerator == other.numerator && this.denominator == other.denominator\n        else -> super.equals(other)\n    }\n\n    override fun hashCode(): Int {\n        var result = numerator.hashCode()\n        result = 31 * result + denominator.hashCode()\n        return result\n    }\n\n    operator fun compareTo(rational: Rational): Int {\n        val (sameBaseThis, sameBaseTarget) = toSameBase(this, rational)\n\n        return when {\n            sameBaseThis.numerator > sameBaseTarget.numerator -> 1\n            sameBaseThis.numerator < sameBaseTarget.numerator -> -1\n            else -> 0\n        }\n    }\n\n    operator fun unaryMinus(): Rational {\n        return Rational(-numerator, denominator)\n    }\n\n    operator fun rangeTo(rational: Rational): Pair<Rational, Rational> {\n        return Pair(this, rational)\n    }\n\n    operator fun plus(target: Rational): Rational {\n        val (sameBaseThis, sameBaseTarget) = toSameBase(this, target)\n        return Rational(\n                numerator = sameBaseThis.numerator + sameBaseTarget.numerator,\n                denominator = sameBaseThis.denominator\n        ).normalize()\n    }\n\n    operator fun minus(target: Rational): Rational {\n        val (sameBaseThis, sameBaseTarget) = toSameBase(this, target)\n        return Rational(\n                numerator = sameBaseThis.numerator - sameBaseTarget.numerator,\n                denominator = sameBaseThis.denominator\n        ).normalize()\n    }\n\n    operator fun times(target: Rational) = Rational(\n            numerator = this.numerator * target.numerator,\n            denominator = this.denominator * target.denominator\n    ).normalize()\n\n    operator fun div(target: Rational) = Rational(\n            numerator = this.numerator * target.denominator,\n            denominator = this.denominator * target.numerator).normalize()\n}\n\noperator fun Pair<Rational, Rational>.contains(rational: Rational): Boolean {\n    return rational >= this.first && rational < this.second\n}\n\nfun String.toRational(): Rational {\n    return if (this.contains("/")) {\n        val (num, den) = this.split("/")\n        Rational(num.toBigInteger(), den.toBigInteger()).normalize()\n    } else {\n        Rational(this.toBigInteger(), ONE)\n    }\n}\n\ninfix fun Number.divBy(first: Number) = Rational(this.toString().toBigInteger(), first.toString().toBigInteger()).normalize()\n\nfun main() {\n    val half = 1 divBy 2\n    val third = 1 divBy 3\n\n    val sum: Rational = half + third\n    println(5 divBy 6 == sum)\n\n    val difference: Rational = half - third\n    println(1 divBy 6 == difference)\n\n    val product: Rational = half * third\n    println(1 divBy 6 == product)\n\n    val quotient: Rational = half / third\n    println(3 divBy 2 == quotient)\n\n    val negation: Rational = -half\n    println(-1 divBy 2 == negation)\n\n    println((2 divBy 1).toString() == "2")\n    println((-2 divBy 4).toString() == "-1/2")\n    println("117/1098".toRational().toString() == "13/122")\n\n    val twoThirds = 2 divBy 3\n    println(half < twoThirds)\n\n    println(half in third..twoThirds)\n\n    println(2000000000L divBy 4000000000L == 1 divBy 2)\n\n    println("912016490186296920119201192141970416029".toBigInteger() divBy\n            "1824032980372593840238402384283940832058".toBigInteger() == 1 divBy 2)\n}\n')),(0,l.kt)("h3",{id:"board"},"Board"),(0,l.kt)("p",null,"Your task is to implement interfaces SquareBoard and GameBoard."),(0,l.kt)("p",null,"SquareBoard stores the information about the square board and all the cells on it. It allows the retrieval of a cell by its indexes, parts of columns and rows on a board, or a specified neighbor of a cell."),(0,l.kt)("p",null,"GameBoard allows you to store values in board cells, update them, and enquire about stored values (like any, all etc.) Note that GameBoard extends SquareBoard."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'data class Cell(val i: Int, val j: Int) {\n    override fun toString() = "($i, $j)"\n}\n\nenum class Direction {\n    UP, DOWN, RIGHT, LEFT;\n\n    fun reversed() = when (this) {\n        UP -> DOWN\n        DOWN -> UP\n        RIGHT -> LEFT\n        LEFT -> RIGHT\n    }\n}\n\ninterface SquareBoard {\n    val width: Int\n\n    fun getCellOrNull(i: Int, j: Int): Cell?\n    fun getCell(i: Int, j: Int): Cell\n\n    fun getAllCells(): Collection<Cell>\n\n    fun getRow(i: Int, jRange: IntProgression): List<Cell>\n    fun getColumn(iRange: IntProgression, j: Int): List<Cell>\n\n    fun Cell.getNeighbour(direction: Direction): Cell?\n}\n\ninterface GameBoard<T> : SquareBoard {\n\n    operator fun get(cell: Cell): T?\n    operator fun set(cell: Cell, value: T?)\n\n    fun filter(predicate: (T?) -> Boolean): Collection<Cell>\n    fun find(predicate: (T?) -> Boolean): Cell?\n    fun any(predicate: (T?) -> Boolean): Boolean\n    fun all(predicate: (T?) -> Boolean): Boolean\n}\n\nopen class SquareBoardImp(final override val width: Int) : SquareBoard {\n\n    private val cells: List<Cell> = sequence {\n        var i = 0\n        repeat(width) {\n            var j = 0\n            i++\n            repeat(width) {\n                j++\n                yield(Cell(i, j))\n            }\n        }\n    }.toList()\n\n    private fun List<Cell>.find(i: Int, j: Int) = this.find { it.i == i && it.j == j }\n\n    override fun getAllCells(): Collection<Cell> {\n        return cells\n    }\n\n    override fun getCell(i: Int, j: Int): Cell = cells.find(i, j)!!\n\n    override fun getCellOrNull(i: Int, j: Int): Cell? = cells.find(i, j)\n\n    override fun getColumn(iRange: IntProgression, j: Int): List<Cell> {\n        return sequence {\n            for (i in iRange) {\n                getCellOrNull(i, j)?.let { yield(it) }\n            }\n        }.toList()\n    }\n\n    override fun getRow(i: Int, jRange: IntProgression): List<Cell> {\n        return sequence {\n            for (j in jRange) {\n                getCellOrNull(i, j)?.let { yield(it) }\n            }\n        }.toList()\n    }\n\n    override fun Cell.getNeighbour(direction: Direction): Cell? {\n        val (i, j) = when (direction) {\n            Direction.UP -> i - 1 to j\n            Direction.DOWN -> i + 1 to j\n            Direction.RIGHT -> i to j + 1\n            Direction.LEFT -> i to j - 1\n        }\n        return cells.find(i, j)\n    }\n}\n\nclass GameBoardImp<T>(size: Int) : SquareBoardImp(size), GameBoard<T> {\n\n    private var values: Set<Pair<Cell, T?>> = this.getAllCells().map { it to null }.toSet()\n\n    override fun get(cell: Cell): T? = values.find { it.first == cell }!!.second\n\n    override fun set(cell: Cell, value: T?) {\n        values = values.map {\n            val updatedValue = if (it.first == cell) value else it.second\n\n            it.first to updatedValue\n        }.toSet()\n    }\n\n    override fun filter(predicate: (T?) -> Boolean): Collection<Cell> {\n        return values.filter { predicate(it.second) }.map { it.first }\n    }\n\n    override fun find(predicate: (T?) -> Boolean): Cell? {\n        return values.find { predicate(it.second) }?.first\n    }\n\n    override fun any(predicate: (T?) -> Boolean): Boolean {\n        return values.any { predicate(it.second) }\n    }\n\n    override fun all(predicate: (T?) -> Boolean): Boolean {\n        return values.all { predicate(it.second) }\n    }\n}\n')),(0,l.kt)("h3",{id:"fibonacci-sequence"},"Fibonacci sequence"),(0,l.kt)("p",null,"Implement the function that builds a sequence of Fibonacci numbers using 'sequence' function. Use 'yield'."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'fun fibonacci(): Sequence<Int> = buildSequence {\n    val elements = Pair(0,1)\n    while(true) {\n        yiled(elements.first)\n        elements = Pair(elements.second, elements.first + elements.second)\n    }\n}\n\nfun main(args: Array<String>) {\n    fibonacci().take(4).toList().toString() eq\n            "[0, 1, 1, 2]"\n\n    fibonacci().take(10).toList().toString() eq\n            "[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"\n}\n\ninfix fun <T> T.eq(other: T) {\n    if (this == other) println("OK")\n    else println("Error: $this != $other")\n}\n')))}p.isMDXComponent=!0},7599:function(e,n,t){"use strict";n.Z=t.p+"assets/images/groupby-associateby-c03a772178e5c5c47ef1312beef0e2cb.png"},3063:function(e,n,t){"use strict";n.Z=t.p+"assets/images/kotlin-result-return-ce5404af52b5cbd502f38c354a59afca.png"},5553:function(e,n,t){"use strict";n.Z=t.p+"assets/images/lambda-receiver-74d85f6fe130d4f820e39031ad28af6e.png"},9906:function(e,n,t){"use strict";n.Z=t.p+"assets/images/sequence-f5df2087c8e6851bc32fd4b48d47716c.png"}}]);